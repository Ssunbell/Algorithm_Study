# 9칸중 8칸에 별을 찍고 가운데 1칸만 별을 찍지 않는다.
# n x n의 이중 리스트를 빈칸으로 채운 다음 그 안을 별로 바꾸면 된다.
# 9칸은 3 x 3으로 이루어져 있기 때문에 이중 for문을 사용한다.
# 이때 (1,1)번째 칸은 빈칸으로 두어야 하기 때문에 조건문을 붙여 이 때는 재귀식이 작동하지 않게 한다.
# n이 첫 인자로 들어갔을 때 다음 n은 n/3이다
# n이 3 x 3 형태로 존재한다면, (n은 원래 n x n형태이지만)
# n의 9칸중 각각의 칸은 n/3 * n/3의 형태를 띄게 된다.
# 따라서 n의 각각의 칸은 n/3의 길이만큼 떨어져야 한다.
# 이때, n을 9칸으로 나누었을때, 각각의 칸의 첫 요소,
# 즉 (0,0)은 다음과 같이 행렬로 나타낼 수 있다.
# (n/3*0,n/3*0) (n/3*0,n/3*1) (n/3*0,n/3*2)
# (n/3*1,n/3*0) (n/3*1,n/3*1) (n/3*1,n/3*2)
# (n/3*2,n/3*0) (n/3*2,n/3*1) (n/3*2,n/3*2)
# 즉, (n/3*2,n/3*2) 인 경우를 빈칸으로 두고 다른 요소를 별로 채우면 된다.

N = int(input())

star_list = [[" " for i in range(N)] for j in range(N)]

def star(n,x,y):
    # 재귀의 탈출식. 빈칸을 별로 바꿈
    if n == 1:
        star_list[x][y]="*"
    # 재귀식
    else:
        # 매번 재귀할때마다 3으로 나눠야함. 3,9,27로 인자가 바뀌기 때문
        next_n = int(n/3)
        # 9칸에 별을 채워야 하기 때문에 3*3반복문
        for i in range(3):
            for j in range(3):
                # (n/3*2,n/3*2) 인 경우를 빈칸으로 두고 다른 요소를 별로 채움
                if i != 1 or j != 1:
                    # 첫 칸은 위의 행렬과 같은 형식이므로, i,j에 첫 칸의 값을 더해서
                    # 9칸의 값을 모두 구한다.
                    star(next_n,x + next_n*i,y+next_n*j)

star(N,0,0)

for i in star_list:
    print("".join(i))